     1                                  %include "../Bootsector/init.inc"
     2                              <1> READ_CYLINDERS equ 10									; 읽을 실린더 수
     3                              <1> FLOPPY_SEGMENT equ 0x07e0								; 읽기 시작할 메모리의 세그먼트
     4                              <1> 
     5                              <1> KERNEL_SEGMENT equ ((0x07e0 * 0x10 + 0x4200 - 0x200) / 0x10)		; 커널의 위치 (0xc000 = 0x07e0 * 0x10 + 0x4200 - 0x200)
     6                                  
     7                                  ; VBE
     8                                  VBE_INFO_SEGMENT equ 0x0200						; VBE의 정보가 저장되는 세그먼트의 위치
     9                                  VBE_MODE equ 0x117								; VBE 화면 모드
    10                                  
    11                                  ; BootInfo
    12                                  BOOT_INFO equ 0x7000							; BootInfo의 위치
    13                                  READ_CYLS equ 0									; 읽어들인 실린더 수
    14                                  SCREEN_X equ 1									; 화면의 X좌표 크기
    15                                  SCREEN_Y equ 3									; 화면의 Y좌표 크기
    16                                  VIDEO_MEMORY equ 5								; 비디오 메모리의 포인터
    17                                  BOOT_INFO_SIZE equ 9							; BootInfo의 크기
    18                                  
    19                                  ; 복사
    20                                  FLOPPY_CPY_ADD equ 0x100000						; 플로피 디스크의 데이터가 복사되는 주소
    21                                  BOOT_INFO_CPY_ADD equ 0x268000					; BootInfo가 복사되는 주소
    22                                  KERNEL_CPY_ADD equ 0x500000						; 커널이 복사되는 주소
    23                                  KERNEL_STACK equ 0x500000						; 커널 스택의 주소
    24                                  KERNEL_SIZE equ (1024*540)						; 커널의 최대 크기 = 540KB
    25                                  
    26                                  [org 0]
    27                                  [bits 16]
    28                                  
    29                                  Kernel_start:
    30 00000000 8CC8                    	mov ax, cs									; cs와 ds를 같게 한다
    31 00000002 8ED8                    	mov ds, ax
    32                                  
    33 00000004 BB0000                  	mov bx, 0
    34 00000007 8EE3                    	mov fs, bx									; fs = 0
    35                                  
    36                                  	; {{16-bit 코드 작성
    37                                  
    38 00000009 64C60600700A            	mov byte [fs:BOOT_INFO + READ_CYLS], READ_CYLINDERS ; 몇 실린더를 읽었는지 BootInfo에 기록
    39                                  
    40 0000000F B80002                  	mov ax, VBE_INFO_SEGMENT
    41 00000012 8EC0                    	mov es, ax
    42 00000014 BF0000                  	mov di, 0									; es:di에 VBE정보가 들어간다
    43 00000017 B8004F                  	mov ax, 0x4f00								; ax=0x4f00 -> VBE정보 및 존재 유무 확인
    44 0000001A CD10                    	int 0x10									; BIOS 호출
    45 0000001C 83F84F                  	cmp ax, 0x004f								; VBE가 있다면 ax의 값은 0x004f이다
    46 0000001F 750B                    	jne vbe_error								; ax가 0x004f가 아니라면 vbe_error로 간다
    47                                  
    48 00000021 268B4504                	mov ax, [es:di + 4]							; es:di + 4에는 버전 정보가 있다.
    49 00000025 3D0002                  	cmp ax, 0x0200								; 버전이 0x0200인지(2.0인지) 이상인지 확인한다
    50 00000028 7202                    	jb vbe_error								; 0x0200 미만이라면 vbe_error로 간다
    51                                  
    52 0000002A EB69                    	jmp vbe_success								; vbe_success로 간다
    53                                  
    54                                  vbe_error:
    55 0000002C BE[4200]                	mov si, vbe_error_msg						; 에러 메세지의 주소
    56                                  putloop:
    57 0000002F 8A04                    	mov al, [si]								; 메세지의 한 글자 읽음
    58 00000031 46                      	inc si										; si++
    59 00000032 3C00                    	cmp al, 0									; al과 0을 비교
    60 00000034 7409                    	je stop										; 0이면 stop으로 jmp
    61 00000036 B40E                    	mov ah, 0x0e								; ah=0x0e -> 화면에 한 글자 출력
    62 00000038 BB0F00                  	mov bx, 15									; 색 코드
    63 0000003B CD10                    	int 0x10									; BIOS 호출(al엔 글자 코드)
    64 0000003D EBF0                    	jmp putloop									; 루프를 돔
    65                                  stop:
    66 0000003F F4                      	hlt											; CPU를 일시정지
    67 00000040 EBFD                    	jmp stop									; 무한루프
    68                                  
    69 00000042 436C7562636F733020-     vbe_error_msg db "Clubcos0 requires VBE 2.0, but this computer doesn't support VBE 2.0. System stop.", 0
    70 0000004B 726571756972657320-
    71 00000054 56424520322E302C20-
    72 0000005D 627574207468697320-
    73 00000066 636F6D707574657220-
    74 0000006F 646F65736E27742073-
    75 00000078 7570706F7274205642-
    76 00000081 4520322E302E205379-
    77 0000008A 7374656D2073746F70-
    78 00000093 2E00               
    79                                  
    80                                  vbe_success:
    81 00000095 B80002                  	mov ax, VBE_INFO_SEGMENT
    82 00000098 8EC0                    	mov es, ax
    83 0000009A BF0000                  	mov di, 0									; es:di에 화면 모드 정보가 들어간다
    84 0000009D B8014F                  	mov ax, 0x4f01								; ax=0x4f01 -> 화면 모드 지원 여부 및 정보 확인
    85 000000A0 B91701                  	mov cx, VBE_MODE								; cx -> 화면 모드
    86 000000A3 CD10                    	int 0x10									; BIOS 호출
    87 000000A5 83F84F                  	cmp ax, 0x004f								; 성공하면 ax의 값은 0x004f이다
    88 000000A8 7582                    	jne vbe_error								; 아니라면 vbe_error로 간다
    89                                  
    90 000000AA 268B4512                	mov ax, [es:di + 0x12]						; 화면 모드+0x12 -> 화면 X방향 크기(2byte = word)
    91 000000AE 64A30170                	mov [fs:BOOT_INFO + SCREEN_X], ax			; BootInfo에 기록
    92 000000B2 268B4514                	mov ax, [es:di + 0x14]						; 화면 모드+0x14 -> 화면 Y방향 크기(2byte = word)
    93 000000B6 64A30370                	mov [fs:BOOT_INFO + SCREEN_Y], ax			; BootInfo에 기록
    94 000000BA 26668B4528              	mov eax, [es:di + 0x28]						; 화면 모드 정보+0x28 -> 비디오 메모리의 위치(pointer = 4byte = dword)
    95 000000BF 6466A30570              	mov [fs:BOOT_INFO + VIDEO_MEMORY], eax		; BootInfo에 기록
    96                                  
    97 000000C4 B8024F                  	mov ax, 0x4f02								; 그래픽 모드로 전환
    98 000000C7 BB1741                  	mov bx, (0100000b << 9) | VBE_MODE			; 화면 갱신 횟수=기본값, 선형 프레임 버퍼 모델, 화면 지움
    99 000000CA CD10                    	int 0x10									; BIOS 호출
   100 000000CC 83F84F                  	cmp ax, 0x004f								; 성공하면 ax의 값은 0x004f이다
   101 000000CF 0F8559FF                	jne vbe_error								; 아니라면 vbe_error로 간다
   102                                  
   103                                  	; 16-bit 코드 작성}}
   104                                  
   105 000000D3 B0FF                    	mov al, 0xff								; PIC 인터럽트 금지
   106 000000D5 E621                    	out 0x21, al								; 마스터 PIC
   107 000000D7 90                      	nop											; 계속 하면 안 될 때도 있으므로 잠시 쉰다.
   108 000000D8 E6A1                    	out 0xa1, al								; 슬레이브 PIC
   109                                  
   110 000000DA FA                      	cli											; CPU 인터럽트 금지
   111                                  
   112 000000DB E88C00                  	call waitkbdout								; 키보드 컨트룰러가 준비될 때까지 기다림
   113 000000DE B0D1                    	mov al, 0xd1								; 키보드 컨트룰러 내부의 포트 번호 지정 (0xdl = 기타 포트)
   114 000000E0 E664                    	out 0x64, al								; out!
   115                                  
   116 000000E2 E88500                  	call waitkbdout								; 키보드 컨트룰러가 준비될 때까지 기다림
   117 000000E5 B0DF                    	mov al, 0xdf								; A20 게이트 활성화 명령어
   118 000000E7 E660                    	out 0x60, al								; out!
   119                                  
   120 000000E9 E87E00                  	call waitkbdout
   121                                  
   122 000000EC 0F0116[7501]            	lgdt [gdtr]									; GDT 로드
   123                                  
   124 000000F1 0F20C0                  	mov eax, cr0								; cr0레지스터의 값을 변경한다.
   125 000000F4 6683C801                	or eax, 0x00000001							; Protected Mode
   126 000000F8 6625FFFFFF7F            	and eax, 0x7fffffff							; 페이징을 사용하지 않음
   127 000000FE 0F22C0                  	mov cr0, eax								; mov!
   128                                  
   129 00000101 66EA[09010000]1800      	jmp dword SysAsmCodeSelector:PM_Start			; 32비트 커널로 점프한다
   130                                  
   131                                  [bits 32]
   132                                  PM_Start:
   133 00000109 66B81000                	mov ax, SysDataSelector						; 세그먼트 초기화
   134 0000010D 8ED8                    	mov ds, ax
   135 0000010F 8EC0                    	mov es, ax
   136 00000111 8EE0                    	mov fs, ax
   137 00000113 8EE8                    	mov gs, ax
   138 00000115 8ED0                    	mov ss, ax
   139 00000117 BC007C0000              	mov esp, 0x7c00								; 스택 초기화
   140                                  
   141                                  	; {{32-bit 코드 작성
   142                                  	; 32-bit 코드 작성}}
   143                                  
   144 0000011C BE007C0000              	mov esi, 0x7c00								; 플로피 디스크의 위치 (부트섹터+읽은 데이터)
   145 00000121 BF00001000              	mov edi, FLOPPY_CPY_ADD						; 복사할 곳
   146 00000126 B900D00200              	mov ecx, READ_CYLINDERS * 512 * 18 * 2		; 복사할 양 계산
   147 0000012B E834000000              	call memcpy									; copy!
   148                                  
   149 00000130 BE[9B431000]            	mov esi, FLOPPY_CPY_ADD + 0x4200 + C_Kernel	; C언어 커널 복사
   150 00000135 BF00005000              	mov edi, KERNEL_CPY_ADD						; 복사할 곳
   151 0000013A B900700800              	mov ecx, KERNEL_SIZE						; 복사할 양
   152 0000013F E820000000              	call memcpy									; copy!
   153                                  
   154 00000144 BE00700000              	mov esi, BOOT_INFO
   155 00000149 BF00802600              	mov edi, BOOT_INFO_CPY_ADD
   156 0000014E B909000000              	mov ecx, BOOT_INFO_SIZE
   157 00000153 E80C000000              	call memcpy
   158                                  
   159 00000158 BC00005000              	mov esp, KERNEL_STACK						; 스택을 KERNEL_STACK으로 설정
   160                                  
   161 0000015D EA000050000800          	jmp SysCodeSelector:KERNEL_CPY_ADD			; 커널로 점프
   162                                  
   163                                  ;-----------;
   164                                  ; Functions ;
   165                                  ;-----------;
   166                                  memcpy:			; 메모리 복사 함수. ds:esi=복사할 데이터 주소, es:edi=복사될 주소, ecx=크기(byte)
   167 00000164 60                      	pushad										; 모든 범용 레지스터 및 일부 인덱스 레지스터 push
   168                                  
   169 00000165 FC                      	cld											; 방향 플래그(DF) = 0 -> 문자열 명령어 실행시 edi, esi 증가
   170 00000166 F3A4                    	rep movsb									; 복사
   171                                  												; rep = ecx가 0일 때까지 명령어를 반복(한번 반복할 때마다 ecx감소)
   172                                  												; movsb = mov의 바이트 문자열 명령어, mov byte [es:edi], [ds:esi]
   173                                  												; 바이트 문자열 명령어이므로 실행후 edi, esi 1증가
   174                                  
   175 00000168 61                      	popad										; 모든 범용 레지스터 및 일부 인덱스 레지스터 pop
   176 00000169 C3                      	ret											; return;
   177                                  
   178                                  waitkbdout:		; 키보드 컨트룰러 대기 함수
   179 0000016A 50                      	push eax									; 사용하는 레지스터(eax) push
   180                                  
   181                                  wait_loop:
   182 0000016B E464                    	in al, 0x64									; 키보드 컨트룰러 상태 in
   183 0000016D 2402                    	and al, 0x2									; 만일 준비가 안 돼있으면 2번째 bit가 0이 됨(따라서 ZF=1)
   184 0000016F E460                    	in al, 0x60									; 키보드 컨트룰러의 버퍼를 비움
   185 00000171 75F8                    	jnz wait_loop								; ZF=0(키보드 컨트룰러가 준비가 안 돼면 루프를 돔
   186                                  
   187 00000173 58                      	pop eax										; 사용하는 레지스터(eax) pop
   188 00000174 C3                      	ret
   189                                  
   190                                  ;-----------;
   191                                  ; GDT Table ;
   192                                  ;-----------;
   193                                  gdtr:
   194 00000175 1F00                    	dw gdt_end - gdt - 1							; GDT의 크기
   195 00000177 [7BBF0000]              	dd gdt + (KERNEL_SEGMENT * 0x10)			; GDT의 시작 주소
   196                                  
   197                                  gdt:											; GDT의 시작
   198                                  
   199                                  NullSelector:									; 예약된 NULL 디스크럽터
   200 0000017B 0000                    	dw 0										; 전부 0
   201 0000017D 0000                    	dw 0
   202 0000017F 00                      	db 0
   203 00000180 00                      	db 0
   204 00000181 00                      	db 0
   205 00000182 00                      	db 0
   206                                  
   207                                  SysCodeSelector equ (1 * 8)					; 코드 세그먼트 디스크럽터
   208 00000183 FFFF                    	dw 0xffff									; Limit 0~15 bit = 0xffff
   209 00000185 0000                    	dw 0										; Base 0~15 bit = 0
   210 00000187 00                      	db 0										; Base 16~23 bit = 0
   211 00000188 9A                      	db 10011010b								; P=1, DPL=0, Code, non-conforming, readable
   212 00000189 CF                      	db 11001111b								; G=1, D=1, Limit 16~19 bit = 0xf (Limit = 0xfffff)
   213 0000018A 00                      	db 0										; Base 24~32 bit = 0 (Base = 0)
   214                                  
   215                                  SysDataSelector equ (2 * 8)					; 데이터 세그먼트 디스크럽터
   216 0000018B FFFF                    	dw 0xffff									; Limit 0~15bit = 0xffff
   217 0000018D 0000                    	dw 0										; Base 0~15 bit = 0
   218 0000018F 00                      	db 0										; Base 16~23 bit = 0
   219 00000190 92                      	db 10010010b								; P=1, DPL=0, Data, expand-up, writable
   220 00000191 CF                      	db 11001111b								; G=1, D=1, Limit 16~19 bit = 0xf (Limit = 0xfffff)
   221 00000192 00                      	db 0										; Base 24~32 bit = 0 (Base = 0)
   222                                  
   223                                  SysAsmCodeSelector equ (3 * 8)				; 임시 코드 세그먼트 디스크럽터
   224 00000193 FFFF                    	dw 0xffff									; Limit 0~15 bit = 0xffff
   225 00000195 00BE                    	dw (KERNEL_SEGMENT * 0x10) & 0xffff			; Base 0~15 bit
   226 00000197 00                      	db (KERNEL_SEGMENT * 0x10) >> 16			; Base 16~23 bit
   227 00000198 9A                      	db 10011010b								; P=1, DPL=0, Code, non-conforming, readable
   228 00000199 CF                      	db 11001111b								; G=1, D=1, Limit 16~19 bit = 0xf (Limit = 0xfffff)
   229 0000019A 00                      	db ((KERNEL_SEGMENT * 0x10) >> 24) & 0xff	; Base 24~32 bit = 0 (Base = KERNEL_SEGMENT * 0x10)
   230                                  
   231                                  gdt_end:										; GDT의 끝 + 1
   232                                  
   233                                  C_Kernel:										; C언어로 만든 커널의 시작
